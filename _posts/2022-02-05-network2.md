---
title:  "HTTP & HTTPS"
excerpt: "Network"

categories:
- CS

toc: True
toc_sticky: True

date: 2022-02-05
last_modified_at: 2022-02-05
---

# HTTP & HTTPS

## HTTP

텍스트 기반 통신 규약으로 인터넷 상에서 데이터를 주고받기 위해 서버/클라이언트 모델을 따르는 프로토콜

- 클라이언트

서버에 요청하는 클라이언트 소프트웨어(IE,Chrome, Firefox, ...)을 이용하고, 클라이언트는 URI를 이용해서 서버에 접속하고 데이터를 요청할 수 있다.

- 서버

클라이언트의 요청을 받아서 요청을 해석하고 응답을 하는 소프트웨어(Apache, nginx, ...)를 이용하고 웹 서버는 보토 표준 포트엔 80번 포트로 서비스한다.

### Request(요청)

클라이언트가 서버에 연락하는 것을 Request라고 하고, request를 보낼 때는 request정보를 담아서 서버로 보낸다.

- GET : 자료를 요청할 때
- POST : 자료의 생성을 요청할 때
- PUT : 자료의 모든 부분에 대해 수정을 요청할 때
- PATCH : 자료 일부분에 대해 수정을 요청할 때
- DELETE : 자료의 삭제를 요청할 때

> Request HTTP message example

```
GET https://www.test.com HTTP/1.1                                     // 시작 줄
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...              // 헤더
Upgrade-Insecure-Requests: 1

// 본문 - 현재는 없음.
```

- 시작 줄 : 메소드 종류, URI, HTTP 버전으로 구성
  - 메소드 종류 : GET
  - URI : https://test.com
  - HTTP 버전 : HTTP/1.1

- 헤더 : 요청에 대한 정보를 담고 있고 User-Agent/Upgrade-Insecure-Requests 등 다양한 헤더가 있음

- 본문
  - 요청 할 때 함께 보내는 데이터를 담는 부분(위 예시는 GET 요청이기에 데이터를 따로 담아 보내지 않기 때문에 비어있다)

### Response

서버가 request에 대한 답변을 클라이언트에 보내는 것 

- 상태코드
  - 1xx(조건부 응답) : 요청을 받았으며 작업을 계속한다.
  - 2xx(성공) : 클라이언트가 요청한 동작을 수신하여 이해했고 성공적을 처리 했다
  - 3xx(redirection 완료) : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야한다
  - 4xx(요청 오류) : 클라이언트에 오류가 있음을 나타냄
  - 5xx(서버 오류) : 서버가 요청을 수행하지 못했음을 나타냄

> Response HTTP message example

```
HTTP/1.1 200 OK               // 시작 줄
Connection: keep-alive       // 헤더
Content-Encoding: gzip                                                 
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title...    // 본문
```

- 시작줄 : HTTP 버전, 상태코드, 상테 메세지로 구성

- 헤더 : 응답에 대한 정보를 담고 있다.

- 본문 : 요청에 대한 응답 메시지를 담아 보낸다.(위 예시에는 HTML이 담겨 있음)

### HTTP 특징

- TCP/IP 위에서 동작하는 응용 프로토콜이다
- 연결 상태를 유지하지 않는 비연결성 프로토콜이다
- 요청/응답 방식으로 동작한다.

- Connectioneless 
  - HTTP는 Connectioneless 방식으로 작동
  - 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어 버리는 특징을 갖고 있음
  - 장점 : 불특정 다수를 대상으로 하는 서비스에 적합 / 많은 사용자가 이용하더라도 접속 유지는 최소한으로 하기 때문에 많은 유저의 요청 처리 가능
  - 단점 : 연결을 끊어버리기 때문에 클라이언트의 이전 상태를 알 수가 없는데, 이러한 HTTP 특징을 Stateless라고 함
  
- Stateless
  - 비연결적성인 특성으로 연결이 해제됨과 동시에 서버와 클라이언트가 이전에 요청한 결과에 대해서 잊어버리게 된다.
  - 그래서 클라이언트가 이전과 같은 데이터를 원하더라도 다시 서버에 연결하여 동일한 요청을 시도해야 한다.

그러나, 상태가 서버에 꼭 저장되야하는 '인증'을 HTTP에서는 어떻게 구현할 수 있을까?

### Cookie 

`쿠키는 웹 브라우저가 보관하는 데이터`를 뜻 한다. 웹 서버는 쿠키를 생성하여 웹 브라우저에 정보를 전송할 수 있고, 쿠키는 'Key-Value' 형태로 웹 브라우저의 쿠키 저장소에 저장된다. 

서버로 부터 쿠키를 전달 받은 웹 브라우저는 이후, 웹 서버에 요청을 보낼 때 쿠키를 헤더에 실어서 함께 전송하고 이를 이용해 웹 서버와 클라이언트는 필요한 값을 공유하고 상태를 유지할 수 있다.

