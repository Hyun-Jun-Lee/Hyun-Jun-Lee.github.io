---
title:  "CPU 스케줄링 & DeadLock"
excerpt: "Operating System"

categories:
- CS

toc: True
toc_sticky: True

date: 2022-01-23
last_modified_at: 2022-01-23
---

# CPU 스케줄링 & DeadLock

## CPU 스케줄링

- 작업을 처리하기 위해 프로세스들에게 중앙처리 장치나 각종 처리기들을 할당하기 위한 정책을 계획하는 것

### 비선점(Nonpreemprive) 스케줄링

- 한 프로세스가 CPU를 할당 받으면 작업 종료 후 CPU 반환 시 까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식
- 모든 프로세스들에게 공정하고 응답시간 예측이 가능하지만, 짧은 작업을 수행하는 프로세스가 긴 작업 종료까지 대기해야 함
- 처리 시간 편차가 적은 특정 프로세스 환경에서 용이

1. FCFS(First Come First Served)
   - 큐에 도착한 순서대로 CPU를 할당
   - 일괄처리 시스템에서 주료 사용되고, 작업 완료 시간 예측 쉬움
   - 짧은 작업이 긴 작업을 기다리게 될수도 있고, 중요하지 않은 작업이 중요한 작업을 기다리게 할수도 있음

2. SJF(Shortest Job First)
    - 준비 큐에서 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
    - FCFS 보다 평균 대기 시간 줄어들고 짧은 작업에 유리

3. HRN(Hightest Response-ratio Next)
    - 우선순위를 계산하여 점유하는 방식으로, 긴 작업과 짧은 작업 간의 불평등을 어느정도 보완
    - $우선순위 = \frac{대기시간+실행시간}{실행시간}$

4. Priority Scheduling
    - 정적/동적으로 우선순위 부여하여 높은 순서대로 처리
    - 순위가 낮은 프로세스가 무한정 기다리는 Starvation 현상 발생 가능

### 선점(Preemptive) 스케줄링

- 우선순위가 높은 프로세스가 현재 프로세스를 중지시키고 CPU를 차지할 수 있는 스케줄링 방식
- 비교적 응답이 빠르다는 장점이 있지만, 처리 시간을 예측하기 힘들고 높은 우선순위 프로세스들이 계속 들어오는 경우 오버헤드
- 높은 우선순위를 가진 프로세스들이 빠른 처리를 요구하는 시스템 / 빠른 응답시간을 요구하는 시분할 시스템에서 유용함

> 시분할 시스템 
> CPU 스케줄링과 다중 프로그래밍을 이용해서 각 사용자들에게 컴퓨터 자원을 시간적으로 분할하여 사용할 수 있게 해주는 대화식 시스템

1. Round Robin
    - 프로세스마다 같은 크기의 CPU 시간을 할당하고, 할당된 시간 내에 완료하지 못하면 준비 큐의 가장 뒤로 보내지고 CPU는 대기중인 다음 프로세스로 넘어감
    - 균등한 CPU 점유 시간 보장
    - 할당 시간(Time Quantum)이 크면 FCFS와 같게 되고 작으면 Context Switiching이 잦아져서 오버헤드 증가

2. SRT(Shot Remaining Time)
    - SJF처럼 수행시간이 가장 짧다고 판단되는 것을 먼저 수행
    - 처리 시간이 더 짧다고 판단되는 프로세스가 준비큐에 생기면 언제라도 프로세스 선점

3. Multilevel Queue Scheduling(다단계 큐 스케줄링)
    - 작업들을 여러 종류의 그룹으로 나누어 여러개의 큐를 이용하는 기법
    - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 Time Quantum을 설정
    - 우선순위가 높은 큐는 작은 Time Quantum, 우선순위가 낮은 큐는 큰 Time Quantum 할당

4. Multilevel-Feedback-Queue(다단계 피드백 큐)
    - 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU 시간 할당량을 부여
    - 짧은 작업에 유리하고, 입출력 위주의 Interrupt가 잦은 작업에 우선권을 줌



### Process state

![image](https://user-images.githubusercontent.com/76996686/150683458-7623fe98-1184-4e6c-8c5f-7dd118c59a00.png)

- 프로세스 상태 
  - 생성 (New) : 프로세스 생성 상태
  - 실행 (Running) : 프로세스가 CPU에 할당되어 실행 중인 상태
  - 준비 (Ready) : 프로세스가 CPU에 할당되기를 기다리는 상태
  - 대기 (Waiting) : 보류(Block)라고도 하며, 프로세스가 입출력이나 이벤트를 기다리는 상태
  - 종료 (Terminated) : 프로세스 종료 상태

- 프로세스 상태 전이
  - 승인 (Admitted) : 프로세스 생성이 가능하여 승인됨.
  - 스케줄러 디스패치 (Scheduler Dispatch) : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.
  - 인터럽트 (Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것.
  - 입출력 또는 이벤트 대기 (I/O or Event wait) : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.
  - 입출력 또는 이벤트 완료 (I/O or Event Completion) : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것.

<br>

## DeadLock

- 프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태(교착상태)
- 두 프로세스가 있을때, 현재 서로 원하는 자원이 상대방에 할당되어 있어서 무한정 wait 상태에 빠지는 경우

> 주로 발생하는 경우

1. 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황
2. 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 발생

### DeadLock 발생 조건

1. 상호 배제(Mutual Exclusion) : 자원은 한번에 한 프로세스만 사용할 수 있음
2. 점유 대기(Hold and wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
3. 비선점(NonPreemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 뺏을 수 없음
4. 순환 대기(Circular Wait) : 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야함

### DeadLock 처리

1. 예방(prevention)

교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)

- 상호배제 부정 : 여러 프로세스가 공유 자원 사용
- 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
- 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
- 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

2. 회피(avoidance)

교착 상태 발생 시 피해나가는 방법

은행원 알고리즘(Banker's Algorithm)

- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
- 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
- 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

3. 탐지(Detection)

자원 할당 그래프를 통해 교착 상태를 탐지함

자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함

4. 회복(Recovery)

교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

- 프로세스 종료 방법

교착 상태의 프로세스를 모두 중지
교착 상태가 제거될 때까지 하나씩 프로세스 중지

- 자원 선점 방법
교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점


