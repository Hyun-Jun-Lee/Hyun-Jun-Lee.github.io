---
title:  "메모리 & 페이징 & 세그먼테이션"
excerpt: "Operating System"

categories:
- CS

toc: True
toc_sticky: True

date: 2022-01-23
last_modified_at: 2022-01-23
---

# 메모리 & 페이징 & 세그먼테이션

## 메모리

- 메인 메모리(주기억장치)

CPU가 직접 접근할 수 있는 기억장치로 프로세스가 실행되려면 프로그램 코드를 메인 메모리에 적재해야 한다. 

- 가상 메모리

메모리 공간은 한정적이므로 사용자에게 더 많은 메모리를 제공하기 위해 가상 주소를 사용한다. 메모리 관리 장치는 가상 주소를 이용해 실제 데이터가 담겨 있는 주소로 변환해주는데, 가상 주소 공간은 하나의 프로세스가 메모리에 저장되는 논리적은 모습을 가상 메모리에 구현한 공간이다.

- 가상 메모리가 필요한 이유
  - 물리 메모리의 한계 : 모든 프로그램을 메모리에 올릴 수 없음
  - 프로그램 용량이 실제 물리 메모리 보다 커도 가능
  - 더 많은 프로그램을 동시에 실행할 수 있음

### 가상 메모리 구현

![image](https://user-images.githubusercontent.com/76996686/151099892-0195dc4c-33cf-4d44-97d9-9c4d2c57b263.png)

OS는 물리 메모리의 제약을 갖고 있는 주기억장치를 보조하기 위해 디스크를 보조기억 장치로 사용한다.

메인 메모리와 디스크의 보조기억장치를 묶어 하나의 메모리처럼 동작하게 한다.

### 연속 메모리 관리

프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되야 한다.

- 고정 분할 기법 : 주기억장치가 고정된 파지션으로 분할(내부 단편화 발생)
- 동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재(외부 단편화 발생)

### 메모리 단편화(Memory Fragmentation)

어떤 프로그램을 실행할 때, 메모리 공간을 연속적인 형태로 할당하여 사용하게 되는데, 이렇게 새로운 프로그램이 할당되고 해제되고를 반복하다 보면 `메모리 공간이 조각조각 나뉘게 되어 실제로는 사용가능한 메모리가 충분하지만 할당이 불가능한 상태가 되고 이를 메모리 단편화` 라고 한다

- 내부 단편화
  - 메모리를 할당할 때, 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황
  ![image](https://user-images.githubusercontent.com/76996686/151100084-0b3ca96d-e937-429d-a0f9-a309fe892b9d.png)


- 외부 단편화
  - 메모리가 할당, 해제 될 때 할당된 메모리와 메모리 사이에 중간중간 사용하지 않은 작은 메모리가 생기는 상황
    ![image](https://user-images.githubusercontent.com/76996686/151100192-f628e591-cee1-4ce3-9cac-607f1dad41d7.png)   

### 불연속 메모리 관리

프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법이다. 앞서 봤던 단편화 문제를 해결하기 위해 제시된 기법으로, 외부 단편화 해소를 위한 페이징과 내부 단편화 해소를 위한 세그멘테이션으로 나뉜다.

### 페이징

프로세스를 일정한 크기의 Page로 분할해서 메모리에 적재하는 방식

- page : 고정 사이즈의 가상 메모리 내 프로세스 조각
- frame : page 크기와 같은 주기억장치의 메모리 조각

#### 페이징 테이블

![image](https://user-images.githubusercontent.com/76996686/151100715-72e1c46c-3819-4487-bbf2-e2eae1989387.png)

`물리 메모리는 고정 크기의 Frame`, `가상 메모리는 고정 크기의 Page`로 분리 되어 있고, 개별 page는 순서에 상관없이 물리 메모리에 있는 Frame에 매핑되어 저장 된다.

즉, 모든 프로세스는 하나의 페이징 테이블을 가지고 있고 여기에는 `메인 메모리에 적재되어 있는 페이지 번호`와 `해당 페이지가 위치한 메인 메모리의 시작 주소`가 있다.

이를 통해 하나의 프로세스를 나눈 가상 메모리의 page들이 각각 실제 메인 메모리의 어디 Frame에 적재되어 있는지 알아낼 수 있다.

> MMU(메모리 관리 장치)는 가상 주소를 이용해 실제 데이터가 담겨 있는 주소로 변환해줌

#### 장단점

- 장점
  - 논리 메모리는 물리 메모리에 저장될 때 연속으로 저장될 필요가 없고, 물리 메모리는 남는 Frame에 적절히 배치되기 때문에 외부 단편화 발생 X

- 단점
  - 내부 단편화 발생 가능, page 단위를 적게하면 해결가능 하지만 그러면 page 매핑 과정이 복잡해져서 비효율적

### 세그먼테이션

세그먼테이션은 프로세스를 물리적 단위인 Page가 아닌 논리적 단위인 Segment로 분할해서 메모리어 적재하는 방식

- Segment : 서로 크기가 다른 논리적 단위

#### 세그먼트 테이블

분할 방식만 다르고 테이블 동작 방식은 같음

#### 장단점

- 장점
  - 내부 단편화 해결
  - 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장 가능

- 단점
  - 외부 단편화 발생 가능


## 자주 나오는 면접 질문

1. 페이징, 세그먼테이션을 사용하는 이유?
프로그램을 실행하기 위해 디스크에서 메인 메모리로 적재하는 과정에서 단편화가 발생한다. 이런 단편화를 해결하기 위해 사용한다.

2. 페이징과 세그먼테이션의 차이?
둘다 프로그램을 실행하기 위해 디스크에 있는 내용을 메모리에 적재하는 불연속 메모리 관리 기법인데 분할하는 방식에 차이가 있다. 페이징은 모든 프로그램을 같은 크기의 페이지로 분할하고 세그먼테이셔은 서로 크기가 다른 세그먼트로 분할한다.