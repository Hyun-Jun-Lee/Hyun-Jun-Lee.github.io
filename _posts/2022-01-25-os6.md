---
title:  "메모리 & 페이징 & 세그먼테이션"
excerpt: "Operating System"

categories:
- CS

toc: True
toc_sticky: True

date: 2022-01-23
last_modified_at: 2022-01-23
---

# 메모리 & 페이징 & 세그먼테이션

## 메모리

- 메인 메모리(주기억장치)

CPU가 직접 접근할 수 있는 기억장치로 프로세스가 실행되려면 프로그램 코드를 메인 메모리에 적재해야 한다. 

- 가상 메모리

메모리 공간은 한정적이므로 사용자에게 더 많은 메모리를 제공하기 위해 가상 주소를 사용한다. 메모리 관리 장치는 가상 주소를 이용해 실제 데이터가 담겨 있는 주소로 변환해주는데, 가상 주소 공간은 하나의 프로세스가 메모리에 저장되는 논리적은 모습을 가상 메모리에 구현한 공간이다.

- 가상 메모리가 필요한 이유
  - 물리 메모리의 한계 : 모든 프로그램을 메모리에 올릴 수 없음
  - 프로그램 용량이 실제 물리 메모리 보다 커도 가능
  - 더 많은 프로그램을 동시에 실행할 수 있음

### 가상 메모리 구현

![image](https://user-images.githubusercontent.com/76996686/151099892-0195dc4c-33cf-4d44-97d9-9c4d2c57b263.png)

OS는 물리 메모리의 제약을 갖고 있는 주기억장치를 보조하기 위해 디스크를 보조기억 장치로 사용한다.

메인 메모리와 디스크의 보조기억장치를 묶어 하나의 메모리처럼 동작하게 한다.

### 연속 메모리 관리

프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되야 한다.

- 고정 분할 기법 : 주기억장치가 고정된 파지션으로 분할(내부 단편화 발생)
- 동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재(외부 단편화 발생)

### 메모리 단편화(Memory Fragmentation)

어떤 프로그램을 실행할 때, 메모리 공간을 연속적인 형태로 할당하여 사용하게 되는데, 이렇게 새로운 프로그램이 할당되고 해제되고를 반복하다 보면 `메모리 공간이 조각조각 나뉘게 되어 실제로는 사용가능한 메모리가 충분하지만 할당이 불가능한 상태가 되고 이를 메모리 단편화` 라고 한다

- 내부 단편화
  - 메모리를 할당할 때, 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황
  ![image](https://user-images.githubusercontent.com/76996686/151100084-0b3ca96d-e937-429d-a0f9-a309fe892b9d.png)


- 외부 단편화
  - 메모리가 할당, 해제 될 때 할당된 메모리와 메모리 사이에 중간중간 사용하지 않은 작은 메모리가 생기는 상황
    ![image](https://user-images.githubusercontent.com/76996686/151100192-f628e591-cee1-4ce3-9cac-607f1dad41d7.png)   

### 불연속 메모리 관리

프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법이다. 앞서 봤던 단편화 문제를 해결하기 위해 제시된 기법으로, 외부 단편화 해소를 위한 페이징과 내부 단편화 해소를 위한 세그멘테이션으로 나뉜다.

#### 페이징

프로세스를 일정한 크기의 Page로 분할해서 메모리에 적재하는 방식

- page : 고정 사이즈의 가상 메모리 내 프로세스 조각
- frame : page 크기와 같은 주기억장치의 메모리 조각
